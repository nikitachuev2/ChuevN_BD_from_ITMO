Задание 1: Выборка данных
Напишите запрос, который выбирает все столбцы из таблицы employees, где должность (job_title) равна 'Manager'.

SELECT * FROM employees WHERE job_title = 'Manager';

В этом задании необходимо выбрать все столбцы из таблицы employees, где должность (job_title) равна 'Manager'.Для этого мы начинаем с оператора SELECT, который используется для выбора данных. В данном случае мы указываем символ *, что означает, что хотим получить все столбцы из таблицы. Далее мы используем оператор FROM, чтобы указать, из какой таблицы мы выбираем данные. В нашем случае это таблица employees.  
Так как условие задания требует выбрать только сотрудников с должностью менеджер,мы добавляем оператор условия WHERE, который позволяет фильтровать результаты. Условие job_title = 'Manager' означает, что мы хотим включить в выборку только те записи, в которых должность соответствует 'Manager'.
 
Задание 2: Применение агрегатных функций
Напишите запрос, который вычисляет среднюю зарплату (salary) всех сотрудников из таблицы employees.

SELECT AVG(salary) AS average_salary FROM employees;

В данном задании требуется вычислить среднюю зарплату (salary) всех сотрудников из таблицы employees.  
Для выполнения этого запроса мы используем агрегатную функцию AVG, которая рассчитывает среднее значение указанного столбца, в нашем случае salary. Мы пишем SELECT AVG(salary) для того, чтобы получить среднюю зарплату. Используя ключевое слово AS, мы задаем новое имя для результата запроса, которое будет отображаться как average_salary. После этого мы указываем, что данные берутся из таблицы employees, используя оператор FROM. 

Задание 3: Группировка данных
Напишите запрос, который группирует сотрудников по должности (job_title) и считает количество сотрудников в каждой должности.

SELECT job_title, COUNT(*) AS employee_count FROM employees GROUP BY job_title;

В этом задании мы группируем сотрудников по их должности (job_title) и считаем количество сотрудников в каждой должности.  
Чтобы реализовать этот запрос, мы начинаем с оператора SELECT, чтобы указать поля, которые мы хотим отобразить: job_title и общее количество сотрудников в каждой группе. Для подсчета количества записей в группах мы используем функцию COUNT(*).  
Далее, мы задаем новое имя для результата подсчета, используя AS employee_count, чтобы сделать вывод более понятным. Затем мы обращаемся к таблице employees с помощью FROM. Чтобы сгруппировать сотрудников по каждой уникальной должности, мы используем оператор GROUP BY job_title. Это позволяет получить количество сотрудников для каждой уникальной должности в таблице.

Задание 4: Фильтрация с условием
Напишите запрос, который выбирает имена (first_name, last_name) всех сотрудников, чья зарплата (salary) превышает 50000.

SELECT first_name, last_name FROM employees WHERE salary > 50000;
 
Начинаем с оператора SELECT, чтобы указать, что мы хотим вывести столбцы first_name и last_name, соответствующие именам и фамилиям сотрудников. Далее мы используем оператор FROM, чтобы указать таблицу employees, из которой мы будем извлекать данные.  
Для фильтрации записей мы применяем условие WHERE, которое позволяет нам выбрать только тех сотрудников, чья зарплата выше 50000. 
  
Задание 5: Сложные условия
Напишите запрос, который выбирает всех сотрудников из таблицы employees, которые работают в отделе (department_id) 3 и имеют зарплату выше среднего значения зарплат по этому отделу.

SELECT * FROM employees WHERE department_id = 3 AND salary > (SELECT AVG(salary) FROM employees WHERE department_id = 3);

Запрос начинается с оператора SELECT *, который указывает на необходимость выбрать все поля для всех сотрудников, соответствующих заданным критериям. Далее, для фильтрации данных используется оператор WHERE, который задает два условия. Первое условие проверяет, что department_id равен 3, что означает, что мы интересуемся только сотрудниками из данного отдела. Второе условие требует, чтобы зарплата текущего сотрудника была больше средней зарплаты в этом же отделе. Здесь применяется подзапрос (SELECT AVG(salary) FROM employees WHERE department_id = 3), который вычисляет среднюю зарплату для отдела с department_id 3. Основной запрос затем сравнивает зарплату каждого сотрудника с полученной средней зарплатой, отбирая всех тех, кто ее превышает. 

Задание 6: Сортировка результатов
Напишите запрос, который выбирает имена (first_name, last_name) и зарплаты (salary) всех сотрудников из таблицы employees, отсортированных по зарплате в порядке убывания.

SELECT first_name, last_name, salary FROM employees ORDER BY salary DESC;

Запрос начинается с оператора SELECT, в котором мы указываем три столбца, которые хотим получить в результате: first_name, last_name и salary. Далее, оператор FROM указывает, что данные будут извлекаться из таблицы employees. Затем следует оператор ORDER BY, который отвечает за сортировку полученных данных. Мы указываем, что сортировка должна происходить по столбцу salary, и добавляем DESC, означающее "по убыванию". Это означает, что сотрудники с наивысшей зарплатой будут перечислены первыми, а с наименьшей — внизу списка. 

Задание 7: Комбинирование группировки и фильтрации
Напишите запрос, который группирует сотрудников по отделу (department_id) и находит минимальную зарплату (salary) в каждом отделе, но выводит только те отделы, где минимальная зарплата превышает 40000.

SELECT department_id, MIN(salary) AS min_salary FROM employees GROUP BY department_id HAVING MIN(salary) > 40000;

Запрос начинается с оператора SELECT, в котором мы указываем, что хотим получить department_id и минимальную зарплату с помощью функции MIN(), которое мы переименовываем с помощью AS min_salary для удобства восприятия результатов. Дальше, мы применяем оператор GROUP BY department_id, который группирует данные по уникальным значениям department_id, что позволяет нам находить минимальную зарплату для каждого отдела. Затем с помощью оператора HAVING мы применяем условие, которое отбирает только те группы, в которых минимальная зарплата превышает 40000    

Задание 8: Использование нескольких агрегатных функций
Напишите запрос, который выбирает максимальную (MAX) и минимальную (MIN) зарплату (salary) из таблицы employees, а также общее количество сотрудников.

SELECT MAX(salary) AS max_salary, MIN(salary) AS min_salary, COUNT(*) AS total_employees FROM employees;

Начнем с оператора SELECT, в котором мы задействуем три агрегатные функции: MAX(salary) для получения максимальной зарплаты, MIN(salary) для нахождения минимальной зарплаты и COUNT(*) для подсчета общего количества сотрудников в данной таблице. Каждой из этих функций мы присваиваем новое имя с помощью AS, что делает результаты более понятными: max_salary, min_salary и total_employees. Оператор FROM employees указывает, что данные извлекаются из таблицы employees. В результате мы получаем одно сводное значение, показывающее максимальную, минимальную зарплату и общее количество сотрудников в таблице

Задание 9: Фильтрация по агрегатам
Напишите запрос, который выбирает все отделы (department_id), где средняя зарплата (average salary) сотрудников больше 60000.

SELECT department_id FROM employees GROUP BY department_id HAVING AVG(salary) > 60000;

SELECT, в котором мы указываем поле department_id. Затем применяется оператор GROUP BY department_id, который группирует результаты по уникальным значениям department_id, что позволяет нам анализировать данные по каждому отделу. Далее мы используем HAVING, чтобы применить условие, которое отбирает только те группы, где средняя зарплата (вычисляемая с помощью функции AVG(salary)) превышает 60000. Это позволяет получить список отделов, которые соответствуют критерию высоких зарплат. 